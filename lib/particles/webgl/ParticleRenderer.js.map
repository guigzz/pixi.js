{"version":3,"sources":["../../../src/particles/webgl/ParticleRenderer.js"],"names":["core","ParticleRenderer","renderer","shader","indexBuffer","properties","tempMatrix","Matrix","CONTEXT_UID","onContextChange","gl","ParticleShader","attribute","attributes","aVertexPosition","size","uploadFunction","uploadVertices","offset","aPositionCoord","uploadPosition","aRotation","uploadRotation","aTextureCoord","uploadUvs","aColor","unsignedByte","uploadTint","start","bindShader","render","container","children","maxSize","_maxSize","batchSize","_batchSize","totalChildren","length","buffers","_glBuffers","generateBuffers","baseTexture","_texture","setBlendMode","utils","correctBlendMode","blendMode","premultipliedAlpha","m","worldTransform","copy","prepend","_activeRenderTarget","projectionMatrix","uniforms","toArray","uColor","premultiplyRgba","tintRgb","worldAlpha","uSampler","bindTexture","updateStatic","i","j","amount","autoResize","push","_generateOneMoreBuffer","buffer","uploadDynamic","bid","_bufferUpdateIDs","_updateID","uploadStatic","bindVao","vao","draw","TRIANGLES","dynamicPropertyFlags","_properties","ParticleBuffer","startIndex","array","stride","w0","w1","h0","h1","sprite","texture","sx","scale","x","sy","y","trim","orig","anchor","width","height","spritePosition","position","spriteRotation","rotation","textureUvs","_uvs","x0","y0","x1","y1","x2","y2","x3","y3","premultiplied","alpha","argb","_tintRGB","destroy","deleteBuffer","indices","ObjectRenderer","WebGLRenderer","registerPlugin"],"mappings":"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","file":"ParticleRenderer.js","sourcesContent":["import * as core from '../../core';\nimport ParticleShader from './ParticleShader';\nimport ParticleBuffer from './ParticleBuffer';\nimport { premultiplyTint } from '../../core/utils';\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java\n */\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI\n */\nexport default class ParticleRenderer extends core.ObjectRenderer\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        // and max number of element in the index buffer is 16384 * 6 = 98304\n        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko\n        // let numIndices = 98304;\n\n        /**\n         * The default shader that is used if a sprite doesn't have a more specific one.\n         *\n         * @member {PIXI.Shader}\n         */\n        this.shader = null;\n\n        this.indexBuffer = null;\n\n        this.properties = null;\n\n        this.tempMatrix = new core.Matrix();\n\n        this.CONTEXT_UID = 0;\n    }\n\n    /**\n     * When there is a WebGL context change\n     *\n     * @private\n     */\n    onContextChange()\n    {\n        const gl = this.renderer.gl;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        // setup default shader\n        this.shader = new ParticleShader(gl);\n\n        this.properties = [\n            // verticesData\n            {\n                attribute: this.shader.attributes.aVertexPosition,\n                size: 2,\n                uploadFunction: this.uploadVertices,\n                offset: 0,\n            },\n            // positionData\n            {\n                attribute: this.shader.attributes.aPositionCoord,\n                size: 2,\n                uploadFunction: this.uploadPosition,\n                offset: 0,\n            },\n            // rotationData\n            {\n                attribute: this.shader.attributes.aRotation,\n                size: 1,\n                uploadFunction: this.uploadRotation,\n                offset: 0,\n            },\n            // uvsData\n            {\n                attribute: this.shader.attributes.aTextureCoord,\n                size: 2,\n                uploadFunction: this.uploadUvs,\n                offset: 0,\n            },\n            // tintData\n            {\n                attribute: this.shader.attributes.aColor,\n                size: 1,\n                unsignedByte: true,\n                uploadFunction: this.uploadTint,\n                offset: 0,\n            },\n        ];\n    }\n\n    /**\n     * Starts a new particle batch.\n     *\n     */\n    start()\n    {\n        this.renderer.bindShader(this.shader);\n    }\n\n    /**\n     * Renders the particle container object.\n     *\n     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n     */\n    render(container)\n    {\n        const children = container.children;\n        const maxSize = container._maxSize;\n        const batchSize = container._batchSize;\n        const renderer = this.renderer;\n        let totalChildren = children.length;\n\n        if (totalChildren === 0)\n        {\n            return;\n        }\n        else if (totalChildren > maxSize)\n        {\n            totalChildren = maxSize;\n        }\n\n        let buffers = container._glBuffers[renderer.CONTEXT_UID];\n\n        if (!buffers)\n        {\n            buffers = container._glBuffers[renderer.CONTEXT_UID] = this.generateBuffers(container);\n        }\n\n        const baseTexture = children[0]._texture.baseTexture;\n\n        // if the uvs have not updated then no point rendering just yet!\n        this.renderer.setBlendMode(core.utils.correctBlendMode(container.blendMode, baseTexture.premultipliedAlpha));\n\n        const gl = renderer.gl;\n\n        const m = container.worldTransform.copy(this.tempMatrix);\n\n        m.prepend(renderer._activeRenderTarget.projectionMatrix);\n\n        this.shader.uniforms.projectionMatrix = m.toArray(true);\n\n        this.shader.uniforms.uColor = core.utils.premultiplyRgba(container.tintRgb,\n            container.worldAlpha, this.shader.uniforms.uColor, baseTexture.premultipliedAlpha);\n\n        // make sure the texture is bound..\n        this.shader.uniforms.uSampler = renderer.bindTexture(baseTexture);\n\n        let updateStatic = false;\n\n        // now lets upload and render the buffers..\n        for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)\n        {\n            let amount = (totalChildren - i);\n\n            if (amount > batchSize)\n            {\n                amount = batchSize;\n            }\n\n            if (j >= buffers.length)\n            {\n                if (!container.autoResize)\n                {\n                    break;\n                }\n                buffers.push(this._generateOneMoreBuffer(container));\n            }\n\n            const buffer = buffers[j];\n\n            // we always upload the dynamic\n            buffer.uploadDynamic(children, i, amount);\n\n            const bid = container._bufferUpdateIDs[j] || 0;\n\n            updateStatic = updateStatic || (buffer._updateID < bid);\n            // we only upload the static content when we have to!\n            if (updateStatic)\n            {\n                buffer._updateID = container._updateID;\n                buffer.uploadStatic(children, i, amount);\n            }\n\n            // bind the buffer\n            renderer.bindVao(buffer.vao);\n            buffer.vao.draw(gl.TRIANGLES, amount * 6);\n        }\n    }\n\n    /**\n     * Creates one particle buffer for each child in the container we want to render and updates internal properties\n     *\n     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n     * @return {PIXI.ParticleBuffer[]} The buffers\n     */\n    generateBuffers(container)\n    {\n        const gl = this.renderer.gl;\n        const buffers = [];\n        const size = container._maxSize;\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        for (let i = 0; i < size; i += batchSize)\n        {\n            buffers.push(new ParticleBuffer(gl, this.properties, dynamicPropertyFlags, batchSize));\n        }\n\n        return buffers;\n    }\n\n    /**\n     * Creates one more particle buffer, because container has autoResize feature\n     *\n     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n     * @return {PIXI.ParticleBuffer} generated buffer\n     * @private\n     */\n    _generateOneMoreBuffer(container)\n    {\n        const gl = this.renderer.gl;\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        return new ParticleBuffer(gl, this.properties, dynamicPropertyFlags, batchSize);\n    }\n\n    /**\n     * Uploads the verticies.\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their vertices uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadVertices(children, startIndex, amount, array, stride, offset)\n    {\n        let w0 = 0;\n        let w1 = 0;\n        let h0 = 0;\n        let h1 = 0;\n\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const texture = sprite._texture;\n            const sx = sprite.scale.x;\n            const sy = sprite.scale.y;\n            const trim = texture.trim;\n            const orig = texture.orig;\n\n            if (trim)\n            {\n                // if the sprite is trimmed and is not a tilingsprite then we need to add the\n                // extra space before transforming the sprite coords..\n                w1 = trim.x - (sprite.anchor.x * orig.width);\n                w0 = w1 + trim.width;\n\n                h1 = trim.y - (sprite.anchor.y * orig.height);\n                h0 = h1 + trim.height;\n            }\n            else\n            {\n                w0 = (orig.width) * (1 - sprite.anchor.x);\n                w1 = (orig.width) * -sprite.anchor.x;\n\n                h0 = orig.height * (1 - sprite.anchor.y);\n                h1 = orig.height * -sprite.anchor.y;\n            }\n\n            array[offset] = w1 * sx;\n            array[offset + 1] = h1 * sy;\n\n            array[offset + stride] = w0 * sx;\n            array[offset + stride + 1] = h1 * sy;\n\n            array[offset + (stride * 2)] = w0 * sx;\n            array[offset + (stride * 2) + 1] = h0 * sy;\n\n            array[offset + (stride * 3)] = w1 * sx;\n            array[offset + (stride * 3) + 1] = h0 * sy;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their positions uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadPosition(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spritePosition = children[startIndex + i].position;\n\n            array[offset] = spritePosition.x;\n            array[offset + 1] = spritePosition.y;\n\n            array[offset + stride] = spritePosition.x;\n            array[offset + stride + 1] = spritePosition.y;\n\n            array[offset + (stride * 2)] = spritePosition.x;\n            array[offset + (stride * 2) + 1] = spritePosition.y;\n\n            array[offset + (stride * 3)] = spritePosition.x;\n            array[offset + (stride * 3) + 1] = spritePosition.y;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadRotation(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spriteRotation = children[startIndex + i].rotation;\n\n            array[offset] = spriteRotation;\n            array[offset + stride] = spriteRotation;\n            array[offset + (stride * 2)] = spriteRotation;\n            array[offset + (stride * 3)] = spriteRotation;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadUvs(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const textureUvs = children[startIndex + i]._texture._uvs;\n\n            if (textureUvs)\n            {\n                array[offset] = textureUvs.x0;\n                array[offset + 1] = textureUvs.y0;\n\n                array[offset + stride] = textureUvs.x1;\n                array[offset + stride + 1] = textureUvs.y1;\n\n                array[offset + (stride * 2)] = textureUvs.x2;\n                array[offset + (stride * 2) + 1] = textureUvs.y2;\n\n                array[offset + (stride * 3)] = textureUvs.x3;\n                array[offset + (stride * 3) + 1] = textureUvs.y3;\n\n                offset += stride * 4;\n            }\n            else\n            {\n                // TODO you know this can be easier!\n                array[offset] = 0;\n                array[offset + 1] = 0;\n\n                array[offset + stride] = 0;\n                array[offset + stride + 1] = 0;\n\n                array[offset + (stride * 2)] = 0;\n                array[offset + (stride * 2) + 1] = 0;\n\n                array[offset + (stride * 3)] = 0;\n                array[offset + (stride * 3) + 1] = 0;\n\n                offset += stride * 4;\n            }\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadTint(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const premultiplied = sprite._texture.baseTexture.premultipliedAlpha;\n            const alpha = sprite.alpha;\n            // we dont call extra function if alpha is 1.0, that's faster\n            const argb = alpha < 1.0 && premultiplied ? premultiplyTint(sprite._tintRGB, alpha)\n                : sprite._tintRGB + (alpha * 255 << 24);\n\n            array[offset] = argb;\n            array[offset + stride] = argb;\n            array[offset + (stride * 2)] = argb;\n            array[offset + (stride * 3)] = argb;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Destroys the ParticleRenderer.\n     *\n     */\n    destroy()\n    {\n        if (this.renderer.gl)\n        {\n            this.renderer.gl.deleteBuffer(this.indexBuffer);\n        }\n\n        super.destroy();\n\n        this.shader.destroy();\n\n        this.indices = null;\n        this.tempMatrix = null;\n    }\n\n}\n\ncore.WebGLRenderer.registerPlugin('particle', ParticleRenderer);\n"]}