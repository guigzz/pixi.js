{"version":3,"sources":["../../../../src/core/sprites/webgl/SpriteRenderer.js"],"names":["TICK","TEXTURE_TICK","SpriteRenderer","renderer","vertSize","vertByteSize","size","settings","SPRITE_BATCH_SIZE","buffers","i","bitTwiddle","nextPow2","push","Buffer","indices","shader","currentIndex","groups","k","textures","textureCount","ids","start","blend","sprites","vertexBuffers","vaos","vaoMax","vertexCount","on","onPrerender","onContextChange","gl","legacy","MAX_TEXTURES","Math","min","getParameter","MAX_TEXTURE_IMAGE_UNITS","SPRITE_MAX_TEXTURES","indexBuffer","glCore","GLBuffer","createIndexBuffer","STATIC_DRAW","bindVao","attrs","attributes","vertexBuffer","createVertexBuffer","STREAM_DRAW","vao","createVao","addIndex","addAttribute","aVertexPosition","FLOAT","aTextureCoord","UNSIGNED_SHORT","aColor","UNSIGNED_BYTE","aTextureId","currentBlendMode","boundTextures","Array","render","sprite","flush","_texture","_uvs","np2","log2","buffer","float32View","uint32View","rendererBoundTextures","touch","textureGC","count","index","nextTexture","currentTexture","groupCount","currentGroup","vertexData","uvs","blendMode","premultiplyBlendMode","baseTexture","premultipliedAlpha","bt","_enabled","emptyTextures","_virtalBoundId","spriteBlendMode","Number","touched","j","tIndex","t","uvsUint32","roundPixels","resolution","alpha","worldAlpha","argb","_tintRGB","CAN_UPLOAD_SAME_BUFFER","upload","vertices","group","groupTextureCount","bindTexture","state","setBlendMode","drawElements","TRIANGLES","bindShader","bind","stop","destroy","off","length","ObjectRenderer","WebGLRenderer","registerPlugin"],"mappings":"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","file":"SpriteRenderer.js","sourcesContent":["import ObjectRenderer from '../../renderers/webgl/utils/ObjectRenderer';\nimport WebGLRenderer from '../../renderers/webgl/WebGLRenderer';\nimport createIndicesForQuads from '../../utils/createIndicesForQuads';\nimport generateMultiTextureShader from './generateMultiTextureShader';\nimport checkMaxIfStatmentsInShader from '../../renderers/webgl/utils/checkMaxIfStatmentsInShader';\nimport Buffer from './BatchBuffer';\nimport settings from '../../settings';\nimport { premultiplyBlendMode, premultiplyTint } from '../../utils';\nimport glCore from 'pixi-gl-core';\nimport bitTwiddle from 'bit-twiddle';\n\nlet TICK = 0;\nlet TEXTURE_TICK = 0;\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @private\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport default class SpriteRenderer extends ObjectRenderer\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        /**\n         * Number of values sent in the vertex buffer.\n         * aVertexPosition(2), aTextureCoord(1), aColor(1), aTextureId(1) = 5\n         *\n         * @member {number}\n         */\n        this.vertSize = 5;\n\n        /**\n         * The size of the vertex information in bytes.\n         *\n         * @member {number}\n         */\n        this.vertByteSize = this.vertSize * 4;\n\n        /**\n         * The number of images in the SpriteRenderer before it flushes.\n         *\n         * @member {number}\n         */\n        this.size = settings.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop\n\n        // the total number of bytes in our batch\n        // let numVerts = this.size * 4 * this.vertByteSize;\n\n        this.buffers = [];\n        for (let i = 1; i <= bitTwiddle.nextPow2(this.size); i *= 2)\n        {\n            this.buffers.push(new Buffer(i * 4 * this.vertByteSize));\n        }\n\n        /**\n         * Holds the indices of the geometry (quads) to draw\n         *\n         * @member {Uint16Array}\n         */\n        this.indices = createIndicesForQuads(this.size);\n\n        /**\n         * The default shaders that is used if a sprite doesn't have a more specific one.\n         * there is a shader for each number of textures that can be rendererd.\n         * These shaders will also be generated on the fly as required.\n         * @member {PIXI.Shader[]}\n         */\n        this.shader = null;\n\n        this.currentIndex = 0;\n        this.groups = [];\n\n        for (let k = 0; k < this.size; k++)\n        {\n            this.groups[k] = { textures: [], textureCount: 0, ids: [], size: 0, start: 0, blend: 0 };\n        }\n\n        this.sprites = [];\n\n        this.vertexBuffers = [];\n        this.vaos = [];\n\n        this.vaoMax = 2;\n        this.vertexCount = 0;\n\n        this.renderer.on('prerender', this.onPrerender, this);\n    }\n\n    /**\n     * Sets up the renderer context and necessary buffers.\n     *\n     * @private\n     */\n    onContextChange()\n    {\n        const gl = this.renderer.gl;\n\n        if (this.renderer.legacy)\n        {\n            this.MAX_TEXTURES = 1;\n        }\n        else\n        {\n            // step 1: first check max textures the GPU can handle.\n            this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);\n\n            // step 2: check the maximum number of if statements the shader can have too..\n            this.MAX_TEXTURES = checkMaxIfStatmentsInShader(this.MAX_TEXTURES, gl);\n        }\n\n        this.shader = generateMultiTextureShader(gl, this.MAX_TEXTURES);\n\n        // create a couple of buffers\n        this.indexBuffer = glCore.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);\n\n        // we use the second shader as the first one depending on your browser may omit aTextureId\n        // as it is not used by the shader so is optimized out.\n\n        this.renderer.bindVao(null);\n\n        const attrs = this.shader.attributes;\n\n        for (let i = 0; i < this.vaoMax; i++)\n        {\n            /* eslint-disable max-len */\n            const vertexBuffer = this.vertexBuffers[i] = glCore.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\n            /* eslint-enable max-len */\n\n            // build the vao object that will render..\n            const vao = this.renderer.createVao()\n                .addIndex(this.indexBuffer)\n                .addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0)\n                .addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4)\n                .addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);\n\n            if (attrs.aTextureId)\n            {\n                vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);\n            }\n\n            this.vaos[i] = vao;\n        }\n\n        this.vao = this.vaos[0];\n        this.currentBlendMode = 99999;\n\n        this.boundTextures = new Array(this.MAX_TEXTURES);\n    }\n\n    /**\n     * Called before the renderer starts rendering.\n     *\n     */\n    onPrerender()\n    {\n        this.vertexCount = 0;\n    }\n\n    /**\n     * Renders the sprite object.\n     *\n     * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch\n     */\n    render(sprite)\n    {\n        // TODO set blend modes..\n        // check texture..\n        if (this.currentIndex >= this.size)\n        {\n            this.flush();\n        }\n\n        // get the uvs for the texture\n\n        // if the uvs have not updated then no point rendering just yet!\n        if (!sprite._texture._uvs)\n        {\n            return;\n        }\n\n        // push a texture.\n        // increment the batchsize\n        this.sprites[this.currentIndex++] = sprite;\n    }\n\n    /**\n     * Renders the content and empties the current batch.\n     *\n     */\n    flush()\n    {\n        if (this.currentIndex === 0)\n        {\n            return;\n        }\n\n        const gl = this.renderer.gl;\n        const MAX_TEXTURES = this.MAX_TEXTURES;\n\n        const np2 = bitTwiddle.nextPow2(this.currentIndex);\n        const log2 = bitTwiddle.log2(np2);\n        const buffer = this.buffers[log2];\n\n        const sprites = this.sprites;\n        const groups = this.groups;\n\n        const float32View = buffer.float32View;\n        const uint32View = buffer.uint32View;\n\n        const boundTextures = this.boundTextures;\n        const rendererBoundTextures = this.renderer.boundTextures;\n        const touch = this.renderer.textureGC.count;\n\n        let index = 0;\n        let nextTexture;\n        let currentTexture;\n        let groupCount = 1;\n        let textureCount = 0;\n        let currentGroup = groups[0];\n        let vertexData;\n        let uvs;\n        let blendMode = premultiplyBlendMode[\n            sprites[0]._texture.baseTexture.premultipliedAlpha ? 1 : 0][sprites[0].blendMode];\n\n        currentGroup.textureCount = 0;\n        currentGroup.start = 0;\n        currentGroup.blend = blendMode;\n\n        TICK++;\n\n        let i;\n\n        // copy textures..\n        for (i = 0; i < MAX_TEXTURES; ++i)\n        {\n            const bt = rendererBoundTextures[i];\n\n            if (bt._enabled === TICK)\n            {\n                boundTextures[i] = this.renderer.emptyTextures[i];\n                continue;\n            }\n\n            boundTextures[i] = bt;\n            bt._virtalBoundId = i;\n            bt._enabled = TICK;\n        }\n        TICK++;\n\n        for (i = 0; i < this.currentIndex; ++i)\n        {\n            // upload the sprite elemetns...\n            // they have all ready been calculated so we just need to push them into the buffer.\n            const sprite = sprites[i];\n\n            nextTexture = sprite._texture.baseTexture;\n\n            const spriteBlendMode = premultiplyBlendMode[Number(nextTexture.premultipliedAlpha)][sprite.blendMode];\n\n            if (blendMode !== spriteBlendMode)\n            {\n                // finish a group..\n                blendMode = spriteBlendMode;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = MAX_TEXTURES;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._enabled !== TICK)\n                {\n                    if (textureCount === MAX_TEXTURES)\n                    {\n                        TICK++;\n\n                        currentGroup.size = i - currentGroup.start;\n\n                        textureCount = 0;\n\n                        currentGroup = groups[groupCount++];\n                        currentGroup.blend = blendMode;\n                        currentGroup.textureCount = 0;\n                        currentGroup.start = i;\n                    }\n\n                    nextTexture.touched = touch;\n\n                    if (nextTexture._virtalBoundId === -1)\n                    {\n                        for (let j = 0; j < MAX_TEXTURES; ++j)\n                        {\n                            const tIndex = (j + TEXTURE_TICK) % MAX_TEXTURES;\n\n                            const t = boundTextures[tIndex];\n\n                            if (t._enabled !== TICK)\n                            {\n                                TEXTURE_TICK++;\n\n                                t._virtalBoundId = -1;\n\n                                nextTexture._virtalBoundId = tIndex;\n\n                                boundTextures[tIndex] = nextTexture;\n                                break;\n                            }\n                        }\n                    }\n\n                    nextTexture._enabled = TICK;\n\n                    currentGroup.textureCount++;\n                    currentGroup.ids[textureCount] = nextTexture._virtalBoundId;\n                    currentGroup.textures[textureCount++] = nextTexture;\n                }\n            }\n\n            vertexData = sprite.vertexData;\n\n            // TODO this sum does not need to be set each frame..\n            uvs = sprite._texture._uvs.uvsUint32;\n\n            if (this.renderer.roundPixels)\n            {\n                const resolution = this.renderer.resolution;\n\n                // xy\n                float32View[index] = ((vertexData[0] * resolution) | 0) / resolution;\n                float32View[index + 1] = ((vertexData[1] * resolution) | 0) / resolution;\n\n                // xy\n                float32View[index + 5] = ((vertexData[2] * resolution) | 0) / resolution;\n                float32View[index + 6] = ((vertexData[3] * resolution) | 0) / resolution;\n\n                // xy\n                float32View[index + 10] = ((vertexData[4] * resolution) | 0) / resolution;\n                float32View[index + 11] = ((vertexData[5] * resolution) | 0) / resolution;\n\n                // xy\n                float32View[index + 15] = ((vertexData[6] * resolution) | 0) / resolution;\n                float32View[index + 16] = ((vertexData[7] * resolution) | 0) / resolution;\n            }\n            else\n            {\n                // xy\n                float32View[index] = vertexData[0];\n                float32View[index + 1] = vertexData[1];\n\n                // xy\n                float32View[index + 5] = vertexData[2];\n                float32View[index + 6] = vertexData[3];\n\n                // xy\n                float32View[index + 10] = vertexData[4];\n                float32View[index + 11] = vertexData[5];\n\n                // xy\n                float32View[index + 15] = vertexData[6];\n                float32View[index + 16] = vertexData[7];\n            }\n\n            uint32View[index + 2] = uvs[0];\n            uint32View[index + 7] = uvs[1];\n            uint32View[index + 12] = uvs[2];\n            uint32View[index + 17] = uvs[3];\n            /* eslint-disable max-len */\n            const alpha = Math.min(sprite.worldAlpha, 1.0);\n            // we dont call extra function if alpha is 1.0, that's faster\n            const argb = alpha < 1.0 && nextTexture.premultipliedAlpha ? premultiplyTint(sprite._tintRGB, alpha)\n                : sprite._tintRGB + (alpha * 255 << 24);\n\n            uint32View[index + 3] = uint32View[index + 8] = uint32View[index + 13] = uint32View[index + 18] = argb;\n            float32View[index + 4] = float32View[index + 9] = float32View[index + 14] = float32View[index + 19] = nextTexture._virtalBoundId;\n            /* eslint-enable max-len */\n\n            index += 20;\n        }\n\n        currentGroup.size = i - currentGroup.start;\n\n        if (!settings.CAN_UPLOAD_SAME_BUFFER)\n        {\n            // this is still needed for IOS performance..\n            // it really does not like uploading to the same buffer in a single frame!\n            if (this.vaoMax <= this.vertexCount)\n            {\n                this.vaoMax++;\n\n                const attrs = this.shader.attributes;\n\n                /* eslint-disable max-len */\n                const vertexBuffer = this.vertexBuffers[this.vertexCount] = glCore.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\n                /* eslint-enable max-len */\n\n                // build the vao object that will render..\n                const vao = this.renderer.createVao()\n                    .addIndex(this.indexBuffer)\n                    .addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0)\n                    .addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4)\n                    .addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);\n\n                if (attrs.aTextureId)\n                {\n                    vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);\n                }\n\n                this.vaos[this.vertexCount] = vao;\n            }\n\n            this.renderer.bindVao(this.vaos[this.vertexCount]);\n\n            this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, false);\n\n            this.vertexCount++;\n        }\n        else\n        {\n            // lets use the faster option, always use buffer number 0\n            this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, true);\n        }\n\n        for (i = 0; i < MAX_TEXTURES; ++i)\n        {\n            rendererBoundTextures[i]._virtalBoundId = -1;\n        }\n\n        // render the groups..\n        for (i = 0; i < groupCount; ++i)\n        {\n            const group = groups[i];\n            const groupTextureCount = group.textureCount;\n\n            for (let j = 0; j < groupTextureCount; j++)\n            {\n                currentTexture = group.textures[j];\n\n                // reset virtual ids..\n                // lets do a quick check..\n                if (rendererBoundTextures[group.ids[j]] !== currentTexture)\n                {\n                    this.renderer.bindTexture(currentTexture, group.ids[j], true);\n                }\n\n                // reset the virtualId..\n                currentTexture._virtalBoundId = -1;\n            }\n\n            // set the blend mode..\n            this.renderer.state.setBlendMode(group.blend);\n\n            gl.drawElements(gl.TRIANGLES, group.size * 6, gl.UNSIGNED_SHORT, group.start * 6 * 2);\n        }\n\n        // reset elements for the next flush\n        this.currentIndex = 0;\n    }\n\n    /**\n     * Starts a new sprite batch.\n     */\n    start()\n    {\n        this.renderer.bindShader(this.shader);\n\n        if (settings.CAN_UPLOAD_SAME_BUFFER)\n        {\n            // bind buffer #0, we don't need others\n            this.renderer.bindVao(this.vaos[this.vertexCount]);\n\n            this.vertexBuffers[this.vertexCount].bind();\n        }\n    }\n\n    /**\n     * Stops and flushes the current batch.\n     *\n     */\n    stop()\n    {\n        this.flush();\n    }\n\n    /**\n     * Destroys the SpriteRenderer.\n     *\n     */\n    destroy()\n    {\n        for (let i = 0; i < this.vaoMax; i++)\n        {\n            if (this.vertexBuffers[i])\n            {\n                this.vertexBuffers[i].destroy();\n            }\n            if (this.vaos[i])\n            {\n                this.vaos[i].destroy();\n            }\n        }\n\n        if (this.indexBuffer)\n        {\n            this.indexBuffer.destroy();\n        }\n\n        this.renderer.off('prerender', this.onPrerender, this);\n\n        super.destroy();\n\n        if (this.shader)\n        {\n            this.shader.destroy();\n            this.shader = null;\n        }\n\n        this.vertexBuffers = null;\n        this.vaos = null;\n        this.indexBuffer = null;\n        this.indices = null;\n\n        this.sprites = null;\n\n        for (let i = 0; i < this.buffers.length; ++i)\n        {\n            this.buffers[i].destroy();\n        }\n    }\n}\n\nWebGLRenderer.registerPlugin('sprite', SpriteRenderer);\n"]}