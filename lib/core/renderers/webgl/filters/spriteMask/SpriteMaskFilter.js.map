{"version":3,"sources":["../../../../../../src/core/renderers/webgl/filters/spriteMask/SpriteMaskFilter.js"],"names":["SpriteMaskFilter","sprite","maskMatrix","Matrix","renderable","maskSprite","apply","filterManager","input","output","tex","texture","valid","transform","TextureMatrix","update","uniforms","mask","otherMatrix","calculateSpriteMatrix","prepend","mapCoord","alpha","worldAlpha","maskClamp","uClampFrame","applyFilter","Filter"],"mappings":";;;;AAAA;;;;AACA;;AAEA;;AACA;;;;;;;;;;;;AAEA;;;;;;;IAOqBA,gB;;;AAEjB;;;AAGA,8BAAYC,MAAZ,EACA;AAAA;;AACI,YAAMC,aAAa,IAAIC,YAAJ,EAAnB;;AADJ,qDAGI,ujCAHJ;;AAQIF,eAAOG,UAAP,GAAoB,KAApB;;AAEA,cAAKC,UAAL,GAAkBJ,MAAlB;AACA,cAAKC,UAAL,GAAkBA,UAAlB;AAXJ;AAYC;;AAED;;;;;;;;;+BAOAI,K,kBAAMC,a,EAAeC,K,EAAOC,M,EAC5B;AACI,YAAMJ,aAAa,KAAKA,UAAxB;AACA,YAAMK,MAAM,KAAKL,UAAL,CAAgBM,OAA5B;;AAEA,YAAI,CAACD,IAAIE,KAAT,EACA;AACI;AACH;AACD,YAAI,CAACF,IAAIG,SAAT,EACA;AACI;AACA;AACAH,gBAAIG,SAAJ,GAAgB,IAAIC,uBAAJ,CAAkBJ,GAAlB,EAAuB,GAAvB,CAAhB;AACH;AACDA,YAAIG,SAAJ,CAAcE,MAAd;;AAEA,aAAKC,QAAL,CAAcC,IAAd,GAAqBP,GAArB;AACA,aAAKM,QAAL,CAAcE,WAAd,GAA4BX,cAAcY,qBAAd,CAAoC,KAAKjB,UAAzC,EAAqDG,UAArD,EACvBe,OADuB,CACfV,IAAIG,SAAJ,CAAcQ,QADC,CAA5B;AAEA,aAAKL,QAAL,CAAcM,KAAd,GAAsBjB,WAAWkB,UAAjC;AACA,aAAKP,QAAL,CAAcQ,SAAd,GAA0Bd,IAAIG,SAAJ,CAAcY,WAAxC;;AAEAlB,sBAAcmB,WAAd,CAA0B,IAA1B,EAAgClB,KAAhC,EAAuCC,MAAvC;AACH,K;;;EAnDyCkB,gB;;kBAAzB3B,gB","file":"SpriteMaskFilter.js","sourcesContent":["import Filter from '../Filter';\nimport { Matrix } from '../../../../math';\nimport { readFileSync } from 'fs';\nimport { join } from 'path';\nimport { default as TextureMatrix } from '../../../../textures/TextureMatrix';\n\n/**\n * The SpriteMaskFilter class\n *\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI\n */\nexport default class SpriteMaskFilter extends Filter\n{\n    /**\n     * @param {PIXI.Sprite} sprite - the target sprite\n     */\n    constructor(sprite)\n    {\n        const maskMatrix = new Matrix();\n\n        super(\n            readFileSync(join(__dirname, './spriteMaskFilter.vert'), 'utf8'),\n            readFileSync(join(__dirname, './spriteMaskFilter.frag'), 'utf8')\n        );\n\n        sprite.renderable = false;\n\n        this.maskSprite = sprite;\n        this.maskMatrix = maskMatrix;\n    }\n\n    /**\n     * Applies the filter\n     *\n     * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from\n     * @param {PIXI.RenderTarget} input - The input render target.\n     * @param {PIXI.RenderTarget} output - The target to output to.\n     */\n    apply(filterManager, input, output)\n    {\n        const maskSprite = this.maskSprite;\n        const tex = this.maskSprite.texture;\n\n        if (!tex.valid)\n        {\n            return;\n        }\n        if (!tex.transform)\n        {\n            // margin = 0.0, let it bleed a bit, shader code becomes easier\n            // assuming that atlas textures were made with 1-pixel padding\n            tex.transform = new TextureMatrix(tex, 0.0);\n        }\n        tex.transform.update();\n\n        this.uniforms.mask = tex;\n        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite)\n            .prepend(tex.transform.mapCoord);\n        this.uniforms.alpha = maskSprite.worldAlpha;\n        this.uniforms.maskClamp = tex.transform.uClampFrame;\n\n        filterManager.applyFilter(this, input, output);\n    }\n}\n"]}